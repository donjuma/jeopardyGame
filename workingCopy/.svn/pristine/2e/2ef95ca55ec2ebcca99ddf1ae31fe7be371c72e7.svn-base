/* server.c - code for example server program that uses TCP */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>

#define QLEN 6 /* size of request queue */
int visits = 0; /* counts client connections */

/*------------------------------------------------------------------------
* Program: server
*
* Purpose: allocate a socket and then repeatedly execute the following:
* (1) wait for the next connection from a client
* (2) send a short message to the client
* (3) close the connection
* (4) go back to step (1)
*
* Syntax: server [ port ]
*
* port - protocol port number to use
*
* Note: The port argument is optional. If no port is specified,
* the server uses the default given by PROTOPORT.
*
*------------------------------------------------------------------------
*/

int main(int argc, char **argv) {
    struct protoent *ptrp; /* pointer to a protocol table entry */
    struct sockaddr_in sad; /* structure to hold server's address */
    struct sockaddr_in cad; /* structure to hold client's address */
    int sd, sd2; /* socket descriptors */
    int port; /* protocol port number */
    int alen; /* length of address */
    char buf[1000]; /* buffer for string the server sends */
    pid_t pid;
    if( argc != 3 ) {
        fprintf(stderr,"Error: Wrong number of arguments\n");
        fprintf(stderr,"usage:\n");
        fprintf(stderr,"./server server_port\n");
        exit(EXIT_FAILURE);
    }

    memset((char *)&sad,0,sizeof(sad)); /* clear sockaddr structure */
    sad.sin_family = AF_INET; /* set family to Internet */
    sad.sin_addr.s_addr = INADDR_ANY; /* set the local IP address */

    port = atoi(argv[1]); /* convert argument to binary */
    if (port > 0) { /* test for illegal value */
        sad.sin_port = htons((u_short)port);
    } else { /* print error message and exit */
        fprintf(stderr,"Error: Bad port number %s\n",argv[1]);
        exit(EXIT_FAILURE);
    }

    /* Map TCP transport protocol name to protocol number */
    if ( ((long int)(ptrp = getprotobyname("tcp"))) == 0) {
        fprintf(stderr, "Error: Cannot map \"tcp\" to protocol number");
        exit(EXIT_FAILURE);
    }

    /* Create a socket */
    sd = socket(PF_INET, SOCK_STREAM, ptrp->p_proto);
    if (sd < 0) {
        fprintf(stderr, "Error: Socket creation failed\n");
        exit(EXIT_FAILURE);
    }

    /* Bind a local address to the socket */
    if (bind(sd, (struct sockaddr *)&sad, sizeof(sad)) < 0) {
        fprintf(stderr,"Error: Bind failed\n");
        exit(EXIT_FAILURE);
    }

    /* Specify size of request queue */
    if (listen(sd, QLEN) < 0) {
        fprintf(stderr,"Error: Listen failed\n");
        exit(EXIT_FAILURE);
    }

    /* Main server loop - accept and handle requests */
    for (;;) {
        alen = sizeof(cad);
        if ( (sd2=accept(sd, (struct sockaddr *)&cad, &alen)) < 0) {
            fprintf(stderr, "Error: Accept failed\n");
            exit(EXIT_FAILURE);
        }

        signal(SIGCHLD,SIG_IGN);

        /*Child process logic  */
        pid = fork();

        if (pid < 0){
            printf("Error in fork\n");
        }

        else if (pid == 0) {
            close(sd);
            int previous_distance = 0;
            int current_guess = 0;
            int current_distance = 0;
            int secret = atoi(argv[2]);
            while(1) {
                read(sd2, &current_guess, sizeof(&current_guess));
                sleep(1);
                // current_guess = ntohl(current_guess);
                printf("Current guess: %d\n", current_guess);
                printf("Previous distance: %d\n", previous_distance);
                current_distance = abs(secret - current_guess);

                printf("Current distance: %d\n", current_distance);

                if (current_guess == secret){
                    buf[0] = '0';
                }
                else if ( (current_distance - previous_distance) == 0) {
                    buf[0] = '3';
                }
                else if ( (current_distance - previous_distance) < 0 ){
                    buf[0] = '1';
                }
                else if ( (current_distance - previous_distance) > 0 ){
                    buf[0] = '2';
                }
                write(sd2, &buf[0], strlen(&buf[0]));
                previous_distance = current_distance;

                printf("\nCurrent distance: %d\n", current_distance);
                printf("Previous distance: %d\n", previous_distance);

                if (buf[0] == '0') {
                    close(sd2);
                    break;
                }
            }
            exit(0);
        }
        else{
            close(sd2);
        }
        /*
        visits++;
        sprintf(buf,"This server has been contacted %d time%s\n",visits,visits==1?".":"s.");
        send(sd2,buf,strlen(buf),0);
        close(sd2);
        */
    }
}
